{
  "Header": {
    "_": [
      " This file for vsSolutionBuildEvent ",
      " https://github.com/3F/vsSolutionBuildEvent "
    ],
    "Compatibility": "0.12.4"
  },
  "PreBuild": [
    {
      "Enabled": true,
      "Name": "ActDir",
      "Caption": "Prepare output directory",
      "Mode": {
        "$type": "net.r_eg.vsSBE.Events.ModeScript, vsSolutionBuildEvent",
        "Type": "Script",
        "Command__": [
          "#[($(Configuration) == \"PublicRelease\") {",
          "    #[$(cfgname = 'Release')]",
          "    $(isPubRel = true)",
          "}",
          "else{",
          "    #[$(cfgname = $(Configuration))]",
          "    $(isPubRel = false)",
          "}]",
          "",
          "#[$(dbin = \"bin/$(cfgname)/\")]",
          "",
          "$(revDeltaBase  = \"2016/10/12\")",
          "$(revDeltaMin   = $([System.Math]::Pow(10, 3)))",
          "$(revDeltaMax   = 65534) //limit of AssemblyVersion (2^16 - 2)",
          "",
          "$(dirsrc        = 'src/')",
          "$(odir          = \"$(dbin)raw/\")",
          "",
          "#[try",
          "{",
          "    #[IO delete.directory(\"$(dbin)\", true)]",
          "}catch{ F-53, SobaScript }]",
          "",
          "#[IO copy.directory(\"\", \"$(dbin)\", true)]"
        ]
      }
    },
    {
      "Enabled": true,
      "Name": "ActSubmodules",
      "Caption": "submodules and packages",
      "Mode": {
        "$type": "net.r_eg.vsSBE.Events.ModeScript, vsSolutionBuildEvent",
        "Type": "Script",
        "Command__": [
          "#[( !(#[IO exists.file(\"$(dirsrc)MvsSln/MvsSln.sln\")]) )",
          "{",
          "    #[File call(\"git\", \"submodule update --init --recursive $(dirsrc)MvsSln\", 300)]",
          "}]",
          "",
          "#[( !(#[IO exists.file(\"$(dirsrc)hMSBuild/hMSBuild.sln\")]) )",
          "{",
          "    #[File call(\"git\", \"submodule update --init --recursive $(dirsrc)hMSBuild\", 300)]",
          "}]",
          "",
          "",
          "~ Packages",
          "",
          "#[( !(#[IO exists.file(\"packages/__checked\")]) )",
          "{",
          "    #[NuGet gnt.raw(\"/p:ngconfig=\\\".tools/packages.config\\\" /nologo /v:m /m:7\")]",
          "    ",
          "    #[IO copy.directory(\"\", \"packages/\", true)]",
          "    #[File write(\"packages/__checked\"): ]",
          "}]",
          "",
          "Call restore target to update nodes due to different options like MvsSlnFeatureHuid=true etc.",
          "#[File scall(\".tools\\hMSBuild.bat\", \"~x ~c $(Configuration) -t:restore DllExport.sln\", 200)]"
        ]
      }
    },
    {
      "Enabled": true,
      "Name": "ActUpdVersions",
      "Caption": "Update version number",
      "Mode": {
        "$type": "net.r_eg.vsSBE.Events.ModeScript, vsSolutionBuildEvent",
        "Type": "Script",
        "Command__": [
          "#[var pVer = #[File get(\".version\")]]",
          "#[var pReleaseVersion = #[File get(\".release.version\")] ]",
          "",
          "Fix possible newlines when committing through GitHub web editor",
          "https://github.com/3F/7z.Libs/commit/67c83ced",
          "#[$(pVer = $(pVer.Trim()))]",
          "#[$(pReleaseVersion = $(pReleaseVersion.Trim()))]",
          "",
          "#[( $(pReleaseVersion) == \"\" )",
          "{",
          "    #[$(partRelV = \"\")]",
          "    #[$(pVerRel  = \"$(pVer)\")]",
          "} else",
          "{",
          "    #[$(partRelV = \"-$(pReleaseVersion)\")]",
          "    #[$(pVerRel  = \"$(pVer)-$(pReleaseVersion)\")]",
          "}]",
          "",
          "#[( ! $(isPubRel) )",
          "{",
          "    #[IO replace.Regex(\"$(dirsrc)DllExportVersion.cs\", \"(\\sS_NUM\\s=).+?\\\";\", \"$1 \\\"$(pVer)\\\";\")]",
          "    #[IO replace.Regex(\"$(dirsrc)DllExportVersion.cs\", \"(\\sS_REL\\s=).+?\\\";\", \"$1 \\\"$(partRelV)\\\";\")]",
          "}]"
        ]
      }
    },
    {
      "Enabled": true,
      "Name": "ActWizardVersion",
      "Caption": "Update WizardVersion",
      "Mode": {
        "$type": "net.r_eg.vsSBE.Events.ModeScript, vsSolutionBuildEvent",
        "Type": "Script",
        "Command__": [
          "#[($(isPubRel))",
          "{",
          "    #[var tBase     = $([System.DateTime]::Parse('$(revDeltaBase)').ToBinary())]",
          "    #[var tNow      = $([System.DateTime]::UtcNow.Ticks)]",
          "    #[var revBuild  = #[$(",
          "        [System.TimeSpan]::FromTicks('$(",
          "            [MSBuild]::Subtract($(tNow), $(tBase))",
          "        )')",
          "        .TotalMinutes.ToString('0')",
          "    )]]",
          "",
          "    #[var revBuild  = #[$(",
          "    ",
          "         [MSBuild]::Add(",
          "             $(revDeltaMin), ",
          "             $([MSBuild]::Modulo(",
          "                 $(revBuild), ",
          "                 $([MSBuild]::Subtract(",
          "                     $(revDeltaMax), $(revDeltaMin)",
          "                  ))",
          "              ))",
          "          )",
          "      ",
          "    )]]",
          "    ",
          "}",
          "else",
          "{",
          "    #[$(revBuild = 0)]",
          "}]",
          "",
          "#[var tpl = // This code was generated by a vsSolutionBuildEvent. ",
          "// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.",
          "namespace net.r_eg.DllExport",
          "{",
          "    using System;",
          "",
          "    internal readonly struct DllExportVersion",
          "    {",
          "        public const string S_NUM = \"$(pVer)\";",
          "        public const string S_REV = \"$(revBuild)\";",
          "        public const string S_REL = \"$(partRelV)\";",
          "",
          "        public const string S_NUM_REV = S_NUM + \".\" + S_REV;",
          "        public const string S_PRODUCT = S_NUM + S_REL;",
          "",
          "        public const string B_SHA1 = \"%B_SHA1%\";",
          "        public const string B_NAME = \"%B_NAME%\";",
          "        public const int B_REVC = %B_REVC%;",
          "",
          "        public const string DXP = \".NET DllExport\";",
          "        public const string SRC = \"%R_URL%\";",
          "        public static readonly Version number = new(S_NUM_REV);",
          "",
          "        internal const string S_INFO        = S_NUM_REV + \"+\" + B_SHA1;",
          "        internal const string S_INFO_P      = S_PRODUCT + \"+\" + B_SHA1;",
          "        internal const string S_INFO_FULL   = S_NUM_REV + S_REL + \"+\" + B_SHA1;",
          "    }",
          "}]",
          "",
          "",
          "#[$(dxpPrintVersion = \"$(pVer).$(revBuild)$(partRelV)\")]",
          "#[$(dxpProductVersion = \"$(pVer)$(partRelV)\")]",
          "",
          "#[\" ",
          "    Checking of the git to define sha1, branch name, etc.",
          "\"]",
          "#[var isGit = #[IO cmd(\"git rev-parse 2>&1\")]]",
          "#[( $(isGit) == \"\" )",
          "{",
          "    #[var bSha1 = #[IO sout(\"git\", \"rev-parse --short HEAD\")]]",
          "    #[var bName = #[IO sout(\"git\", \"rev-parse --abbrev-ref HEAD\")]]",
          "    #[var bRevc = #[IO sout(\"git\", \"rev-list HEAD --count\")]]",
          "    #[var rpUrl = #[IO sout(\"git\", \"config --get remote.origin.url\")]]",
          "",
          "    #[($(bName) == \"HEAD\") {",
          "        #[var bName = $(APPVEYOR_REPO_BRANCH)]",
          "    }]",
          "",
          "    #[$(dxpPrintVersion = \"$(dxpPrintVersion)+$(bSha1)\")]",
          "    #[$(dxpProductVersion = \"$(dxpProductVersion)+$(bSha1)\")]",
          "",
          "    #[$(rpUrl = $(rpUrl.Replace('https://', '').Replace(':', '/')",
          "                       .Replace('git@', '').Replace('.git', '').Replace('www.', '')))]",
          "}",
          "else {",
          "    #[$(bSha1 = '-')] #[$(bName = '-')] #[$(bRevc = '0')] #[$(rpUrl = '')]",
          "}]",
          "",
          "~",
          "",
          "#[($(isPubRel))",
          "{",
          "    #[var tpl = #[$(tpl.Replace(\"%B_SHA1%\", \"#[var bSha1]\")",
          "                       .Replace(\"%B_NAME%\", \"#[var bName]\")",
          "                       .Replace(\"%B_REVC%\", \"#[var bRevc]\")",
          "                       .Replace(\"%R_URL%\",  \"#[var rpUrl]\") )]]",
          "    ",
          "    #[File write(\"$(dirsrc)DllExportVersion.cs\"):#[var tpl]]",
          "}]"
        ]
      }
    }
  ],
  "PostBuild": [
    {
      "Enabled": false,
      "Name": "ShaList",
      "Mode": {
        "$type": "net.r_eg.vsSBE.Events.ModeCSharp, vsSolutionBuildEvent",
        "Type": "CSharp",
        "References": [
          "System.dll"
        ],
        "SmartReferences": true,
        "GenerateInMemory": true,
        "TreatWarningsAsErrors": false,
        "WarningLevel": 4,
        "FilesMode": false,
        "CachingBytecode": false,
        "Command__": [
          "using System;",
          "using System.IO;",
          "using System.Text;",
          "using System.Security.Cryptography;",
          "using ICommand = net.r_eg.vsSBE.Actions.ICommand;",
          "using ISolutionEvent = net.r_eg.vsSBE.Events.ISolutionEvent;",
          "",
          "namespace vsSolutionBuildEvent",
          "{",
          "    public class CSharpMode",
          "    {",
          "        public static int Init(ICommand cmd, ISolutionEvent evt)",
          "        {",
          "            string dir = @\"$(shaListDir)\".Replace('/', '\\\\');",
          "            ",
          "            Func<byte[], string> _BytesToHexView = (data) =>",
          "            {",
          "                var ret = new StringBuilder();",
          "                foreach(byte b in data) ret.Append(b.ToString(\"x2\"));",
          "                return ret.ToString();",
          "            };",
          "",
          "            var values = new StringBuilder();",
          "",
          "            using(SHA1 sha1 = SHA1.Create())",
          "            {",
          "                foreach(var input in Directory.GetFiles(dir, \"*\", (SearchOption)$(searchSubDirs)))",
          "                {",
          "                    using(var stream = new FileStream(input, FileMode.Open, FileAccess.Read))",
          "                    values.AppendLine(string.Format",
          "                    (",
          "                        \"{0} {1}\",",
          "                        _BytesToHexView(sha1.ComputeHash(stream)),",
          "                        input.Replace(dir, \"\")",
          "                    ));",
          "                }",
          "            }",
          "",
          "            using(var w = new StreamWriter(Path.Combine(dir, \".sha1\"), false, new UTF8Encoding(false)))",
          "            w.Write(values.ToString());",
          "            ",
          "            return 0;",
          "        }",
          "    }",
          "}"
        ]
      }
    },
    {
      "Enabled": true,
      "Name": "ActBinaries",
      "Caption": "Binaries & tools ...",
      "IgnoreIfBuildFailed": true,
      "Mode": {
        "$type": "net.r_eg.vsSBE.Events.ModeScript, vsSolutionBuildEvent",
        "Type": "Script",
        "Command__": [
          "#[IO copy.file(",
          "        \"$(SolutionDir).tools/*.*\", ",
          "        \"$(odir)/tools/\", ",
          "        true, ",
          "        {\"packages.config\", \"*.nuspec\", \".pkg.*.txt\"})]",
          "",
          "#[IO copy.file({\".tools/*.nuspec\", \".tools/.pkg.*.txt\"}, \"$(odir)/\", true)]",
          "#[IO replace(\"$(odir)/DllExport.nuspec\", \"$-version-$\", \"$(pVerRel)\")]",
          "",
          "Fallback for DllExport.bat 1.7.4(and older) that rely on hMSBuild.bat (modern contains built-in)",
          "#[IO copy.file(\".tools\\hMSBuild.bat\", \"$(odir)/\", true)]",
          "",
          "#[IO copy.file(",
          "{",
          "    \"$(OutDir:Core)*.*\",",
          "    \"$(OutDir:Activator)*.*\",",
          "    \"$(OutDir:NSBin)*.*\",",
          "    \"$(OutDir:Wizard)*.*\",",
          "    \"$(OutDir:PeViewer)*.*\"",
          "}, ",
          "\"$(odir)/tools/\", true, { \"Mono.Cecil.*.dll\" })]",
          "",
          "https://github.com/3F/DllExport/issues/36",
          "#[IO copy.directory(\"\", \"$(odir)/lib/net20/\", true)]",
          "#[IO write(\"$(odir)/lib/net20/_._\"):]",
          "",
          "#[$(metaCoreTargetVer = $(TargetFramework:MetaCor))]",
          "",
          "#[IO copy.directory(\"\", \"$(odir)/lib/$(metaCoreTargetVer)/\", true)]",
          "#[IO write(\"$(odir)/lib/$(metaCoreTargetVer)/_._\"):]",
          "",
          "",
          "#[IO copy.file(\"$(OutDir:MetaFx)*.dll\", \"$(odir)/tools/raw/lib/net20/\", true)]",
          "#[IO copy.file(\"$(OutDir:MetaCor)*.dll\", \"$(odir)/tools/raw/lib/netstd/\", true)]",
          "",
          "##[IO copy.file(\".tools/build.targets\", \"$(odir)/build/net/DllExport.targets\", true)]",
          "",
          "#[IO copy.file({",
          "    \"Readme.md\",",
          "    \"3rd-party-NOTICES.txt\",",
          "    \"changelog.txt\",",
          "    \"LICENSE.txt\",",
          "    \"AUTHORS.txt\",",
          "    \".gitattributes\",",
          "    \".version\",",
          "    \".release.version\",",
          "    \"tests.bat\"",
          "},",
          "\"$(odir)/\", true)]",
          "",
          "",
          "#[var buildInfo =  $([System.String]::Concat(\"  \"))",
          "    .NET DllExport #[$(dxpProductVersion)]",
          "    ",
          "    ",
          "    Configuration:  #[$(Configuration)]",
          "    ",
          "    Release type:   #[$(pReleaseVersion)]",
          "    ",
          "    Build number:   #[$(revBuild)]",
          "    ",
          "    toolset:        #[$(TargetFramework:Wizard)]",
          "    ",
          "    MetaCor:        #[$(TargetFramework:MetaCor)]",
          "    ",
          "    MetaLib:        #[$(TargetFramework:MetaFx)]",
          "    ",
          "    hMSBuild core:  #[File get(\"$(dirsrc)hMSBuild/.version\")]",
          "    ",
          "    ",
          "    :: generated by a vsSolutionBuildEvent #[$(vsSolutionBuildEvent)]",
          "]",
          "",
          "#[IO writeLine(\"$(odir)/build_info.txt\"):#[var buildInfo]]",
          "",
          "",
          "#[IO replace(\"$(odir)/DllExport.nuspec\", \"{build_info}\", \"$(buildInfo)\")]"
        ]
      }
    },
    {
      "Enabled": true,
      "Name": "XmlMetadata",
      "Caption": "Prepare XML metadata of the library",
      "IgnoreIfBuildFailed": true,
      "Mode": {
        "$type": "net.r_eg.vsSBE.Events.ModeScript, vsSolutionBuildEvent",
        "Type": "Script",
        "Command__": [
          "#[$(IDNS = 'D3F00FF1770DED978EC774BA389F2DC9')]",
          "",
          "#[IO copy.file(\"$(DocumentationFile:MetaFx)\", ",
          "               \"$(odir)/tools/raw/lib/net20/\", true)]",
          "",
          "#[IO replace.Regex(\"$(odir)/tools/raw/lib/net20/DllExport.xml\", \"$(IDNS).*F00+\", \"$(IDNS)\")]",
          "",
          "",
          "#[IO copy.file(\"$(DocumentationFile:MetaCor)\", ",
          "               \"$(odir)/tools/raw/lib/netstd/\", true)]",
          "",
          "#[IO replace.Regex(\"$(odir)/tools/raw/lib/netstd/DllExport.xml\", \"$(IDNS).*F00+\", \"$(IDNS)\")]"
        ]
      }
    },
    {
      "Enabled": true,
      "Name": "ActILAsm",
      "Caption": "IL Assembler and Disassembler",
      "IgnoreIfBuildFailed": true,
      "Mode": {
        "$type": "net.r_eg.vsSBE.Events.ModeScript, vsSolutionBuildEvent",
        "Type": "Script",
        "Command__": [
          "#[$(ILAsmDir = \"src/coreclr/artifacts/pkg/Release/ILAsm/\")]",
          "#[$(ILAsmDirBinX86 = \"$(ILAsmDir)bin/Win.x86/\")]",
          "#[$(ILAsmDirBinX64 = \"$(ILAsmDir)bin/Win.x64/\")]",
          "",
          "#[( $(_dxpILAsmBinX) != 64 ) { #[$(ILAsmDirBin = $(ILAsmDirBinX86))] }",
          "else { #[$(ILAsmDirBin = $(ILAsmDirBinX64))] }]",
          "",
          "#[( #[IO exists.file(\"$(ILAsmDirBin)ilasm.exe\")] )",
          "{",
          "    #[IO copy.file(",
          "        { \"$(ILAsmDirBin)*.*\", \"$(ILAsmDir)*.txt\", \"$(ILAsmDir)*.md\" },",
          "        \"$(odir)/tools/coreclr/\", true)]",
          "}",
          "else",
          "{",
          "    #[IO copy.file(",
          "    {",
          "        \"packages/ILAsm/bin/Win.x86/*.dll\",",
          "        \"packages/ILAsm/bin/Win.x86/*.exe\",",
          "        \"packages/ILAsm/*.txt\",",
          "        \"packages/ILAsm/*.md\"",
          "    }, ",
          "    \"$(odir)/tools/coreclr/\", true)]",
          "}]",
          ""
        ]
      }
    },
    {
      "Enabled": true,
      "Name": "MgrInit",
      "Caption": "Preparing Manager ...",
      "IgnoreIfBuildFailed": true,
      "Process": {
        "$type": "net.r_eg.vsSBE.Events.EventProcess, vsSolutionBuildEvent",
        "Waiting": true,
        "Hidden": false,
        "TimeLimit": 400
      },
      "Mode": {
        "$type": "net.r_eg.vsSBE.Events.ModeScript, vsSolutionBuildEvent",
        "Type": "Script",
        "Command__": [
          "#[IO writeLine(STDOUT): Build hMSBuild and GetNuTool ...]",
          "#[IO call(\"cmd\", \"/C cd $(dirsrc)hMSBuild & build\", 300)]",
          "",
          "#[var frontend = $(dirsrc)DllExport\\\\Manager\\\\batch\\\\Manager.bat]",
          "",
          "",
          "#[$(hCore = '$(dirsrc)hMSBuild\\bin\\Release\\hMSBuild.')]",
          "#[$(embdCore = \"$(hCore)embd\")]",
          "#[IO copy.file(\"$(hCore)bat\", \"$(embdCore)\", true)]",
          "",
          "#[var dxpWZ = $(dbin.Replace('/', '\\\\'))DllExport.bat]",
          "",
          "#[IO copy.file(\"$(frontend)\", \"$(dxpWZ)\", true)]",
          "",
          "#[IO replace(\"$(dxpWZ)\", \"$-pkg-version-$\", \"$(pVerRel)\")]",
          "#[( ! $(isPubRel) )",
          "{",
          "    #[$(wzPrintVer = \"$(pVer)$(partRelV)\")]",
          "    #[( $(Configuration) ~= \"Debug\" )",
          "    {",
          "        #[$(wzPrintVer += \" [ Debug ]\")]",
          "    }]    ",
          "    #[IO replace(\"$(dxpWZ)\", \"$-version-$\", \"$(wzPrintVer)\")]",
          "}",
          "else",
          "{",
          "    #[IO replace(\"$(dxpWZ)\", \"$-version-$\", \"$(dxpPrintVersion)\")]",
          "}]",
          "",
          "",
          "~ compile script",
          "",
          "#[IO writeLine(STDOUT): Generate manager ...]",
          "#[$(mbatch = \"$(SolutionDir)$(dirsrc)DllExport/Manager/batch/\")]",
          "#[$(coreMgrIn = \"$(SolutionDir)$(dxpWZ)\")]",
          "#[$(coreMgrBat = \"$(SolutionDir)$(dxpWZ).m.core.bat\")]",
          "",
          "",
          "~ prepare aliases",
          "#[IO replace(\"$(embdCore)\", \"%~n0\", \"%_kH%\")]"
        ]
      }
    },
    {
      "Enabled": true,
      "Name": "Embd",
      "Caption": "parse bat",
      "Mode": {
        "$type": "net.r_eg.vsSBE.Events.ModeCSharp, vsSolutionBuildEvent",
        "Type": "CSharp",
        "References": [
          "System.dll",
          "System.Core.dll"
        ],
        "SmartReferences": true,
        "GenerateInMemory": true,
        "TreatWarningsAsErrors": false,
        "WarningLevel": 4,
        "FilesMode": false,
        "CachingBytecode": false,
        "Command__": [
          "/*",
          "*   Copyright (c) 2015  Denis Kuzmin <x-3F@outlook.com> github/3F",
          "*",
          "*   Licensed under the GetNuTool license",
          "*   https://github.com/3F/GetNuTool",
          "*",
          "*   Based on compressor from hMSBuild project",
          "*   https://github.com/3F/hMSBuild",
          "*/",
          "",
          "using System;",
          "using System.Collections.Generic;",
          "using System.IO;",
          "using System.Linq;",
          "using System.Text;",
          "using System.Text.RegularExpressions;",
          "using ICommand = net.r_eg.vsSBE.Actions.ICommand;",
          "using ISolutionEvent = net.r_eg.vsSBE.Events.ISolutionEvent;",
          "",
          "namespace vsSolutionBuildEvent",
          "{",
          "    public class CSharpMode",
          "    {",
          "        public static int Init(ICommand cmd, ISolutionEvent evt)",
          "        {",
          "            const string _CORE = @\"$(coreMgrIn)\";",
          "            const string _OUTPUT = @\"$(coreMgrBat)\";",
          "",
          "            Func<char[], int, Func<int, bool>, string[]> gencomb = (_dict, _size, _rule0) =>",
          "            {",
          "                var combination = new char[_size];",
          "                var set = new List<string>((int)Math.Pow(_dict.Length, _size));",
          "",
          "                int pos = 0;",
          "                Action generator = null;",
          "                generator = () =>",
          "                {",
          "                    for(int i = 0, lim = _size - 1; i < _dict.Length; ++i)",
          "                    {",
          "                        if(pos == 0 && !_rule0(i)) continue;",
          "",
          "                        if(pos < lim)",
          "                        {",
          "                            combination[pos] = _dict[i];",
          "                            ++pos;",
          "                            generator();",
          "                            --pos;",
          "                        }",
          "                        else",
          "                        {",
          "                            combination[pos] = _dict[i];",
          "                            set.Add(new String(combination.ToArray()));",
          "                        }",
          "                    }",
          "                };",
          "",
          "                generator();",
          "                return set.ToArray();",
          "            };",
          "",
          "            Func<string, string> review = (input) =>",
          "            {",
          "                /* predefined parser behaviour */",
          "                return Regex.Replace(input, @\"\\s*::&:\\s*&?\", \"\\r\\n\");",
          "            };",
          "",
          "            var variables = new Dictionary<string, string>();",
          "            UTF8Encoding utf8noId = new UTF8Encoding(false);",
          "",
          "            var cdict = new[]",
          "            {",
          "                'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x',",
          "                'y', 'z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h',",
          "                'i', 'j', 'k', 'l', 'm', 'n', '0', '1', '2', '3',",
          "                '4', '5', '6', '7', '8', '9',",
          "                // '_'",
          "            };",
          "",
          "            string[] vdict = gencomb(cdict, 2, (i) => { return char.IsLetter(cdict[i]) || cdict[i] == '_'; });",
          "",
          "            // to skip processing for:",
          "            var exvar = new[] { \"__p_call\", \"__p_msb\", \"msb.gnt.cmd\", \"__dxp_pv\", \"wMgrArgs\", \"wPkgVer\", \"wProxy\", \"wDxpOpt\", \"wSlnDir\", \"wPkgPath\", \"wMetaLib\", \"wMetaCor\", \"wDxpTarget\", \"wAction\", \"wSlnFile\", \"wRootPath\", \"ngserver\", \"logo\", \"debug\", \"_kH\" };",
          "            ",
          "            var apifun = new[] { \"inita\", \"eva\" };",
          "",
          "            const string VNAME = \"[a-z_][a-z_0-9]+\";",
          "            using(var reader = new StreamReader(_CORE, Encoding.UTF8, true))",
          "            {",
          "                string content = reader.ReadToEnd();",
          "",
          "                /* set /a ERROR_ codes */",
          "",
          "                var errorsCodes = new Dictionary<string, string>();",
          "                content = Regex.Replace",
          "                (",
          "                    content,",
          "                    @\"set\\s+\\/a\\s+(?'k'ERROR_[^= ]+)\\s*=\\s*(?'v'\\d+)\",",
          "                    (m) =>",
          "                    {",
          "                        errorsCodes[m.Groups[\"k\"].Value] = m.Groups[\"v\"].Value;",
          "                        return string.Empty;",
          "                    }",
          "                );",
          "",
          "                foreach(var err in errorsCodes)",
          "                {",
          "                    content = Regex.Replace(",
          "                        content,",
          "                        string.Format(\"({1}{0}{1}|{2}{0}{2})\", err.Key, \"%\", \"!\"),",
          "                        err.Value",
          "                    );",
          "                }",
          "",
          "",
          "                /* Shorten variables & labels */",
          "",
          "                uint uniqVars = 0;",
          "                content = Regex.Replace",
          "                (",
          "                    content,",
          "                    @\"(?'def' ",
          "                        set\\s+?",
          "                         (?:\\/\\S\\s+?)?",
          "                         (?:\"\"\\s*?)?",
          "                      )",
          "                      (?'name'\" + VNAME + @\")",
          "                      (?'lim'\\s?\\S?=)\", // aq+=1,.. TODO: aq=aq+1 ; aq=1+aq ...",
          "                    (m) =>",
          "                    {",
          "                        var def     = m.Groups[\"def\"].Value;",
          "                        var vname   = m.Groups[\"name\"].Value;",
          "                        var lim     = m.Groups[\"lim\"].Value;",
          "",
          "                        if(exvar.Contains(vname))",
          "                        {",
          "                            return m.Groups[0].Value;",
          "                        }",
          "",
          "                        if(variables.ContainsKey(vname))",
          "                        {",
          "                            return def + variables[vname] + lim;",
          "                        }",
          "",
          "                        if(uniqVars + 1 > vdict.Length)",
          "                        {",
          "                            throw new OverflowException(\"vdict does not contain data for new vars\");",
          "                        }",
          "                        variables[vname] = vdict[uniqVars++];",
          "                        return def + variables[vname] + lim;",
          "                    },",
          "                    RegexOptions.IgnorePatternWhitespace | RegexOptions.IgnoreCase",
          "                );",
          "",
          "                // call :proc p1 p2 ...",
          "                content = Regex.Replace",
          "                (",
          "                    content,",
          "                    @\"(?'def'call\\s+:\" + VNAME + @\"\\s)(?'args'.+?)(?'eol'&|\\||\\r\\n)\",",
          "                    (m) =>",
          "                    {",
          "                        var def     = m.Groups[\"def\"].Value;",
          "                        var cargs   = m.Groups[\"args\"].Value;",
          "                        var eol     = m.Groups[\"eol\"].Value;",
          "",
          "                        return def + Regex.Replace",
          "                        (",
          "                            cargs,",
          "                            @\"(?'split'^|\\s)(?:(?'str'\"\".+?\"\")|(?'name'\" + VNAME + \"))\",",
          "                            (_m) =>",
          "                            {",
          "                                var split = _m.Groups[\"split\"].Value;",
          "",
          "                                if(_m.Groups[\"str\"].Success)",
          "                                {",
          "                                    return split + _m.Groups[\"str\"].Value;",
          "                                }",
          "",
          "                                var vname = _m.Groups[\"name\"].Value;",
          "",
          "                                if(exvar.Contains(vname) || apifun.Contains(vname))",
          "                                {",
          "                                    return split + vname;",
          "                                }",
          "",
          "                                if(variables.ContainsKey(vname))",
          "                                {",
          "                                    return split + variables[vname];",
          "                                }",
          "",
          "                                if(uniqVars + 1 > vdict.Length)",
          "                                {",
          "                                    throw new OverflowException(\"vdict does not contain data for new vars\");",
          "                                }",
          "                                variables[vname] = vdict[uniqVars++];",
          "                                return split + variables[vname];",
          "                            },",
          "                            RegexOptions.IgnoreCase | RegexOptions.Multiline",
          "                        ) + eol;",
          "                    },",
          "                    RegexOptions.IgnoreCase",
          "                );",
          "",
          "                // %name... & !name...",
          "                content = Regex.Replace",
          "                (",
          "                    content,",
          "                    @\"(?'def'(?:[%!]|\\sdefined\\s+))(?'name'\" + VNAME + \")\",",
          "                    (m) =>",
          "                    {",
          "                        var def     = m.Groups[\"def\"].Value;",
          "                        var vname   = m.Groups[\"name\"].Value;",
          "",
          "                        if(!variables.ContainsKey(vname))",
          "                        {",
          "                            return def + vname;",
          "                        }",
          "                        return def + variables[vname];",
          "                    },",
          "                    RegexOptions.IgnoreCase",
          "                );",
          "",
          "                // labels",
          "                content = Regex.Replace",
          "                (",
          "                    content,",
          "                    @\"(?'def'call\\s*:|^\\s*:|goto\\s*:?)(?'label'\" + VNAME + @\")(?'eol'\\s|&|\\r\\n)\",",
          "                    (m) =>",
          "                    {",
          "                        var def     = m.Groups[\"def\"].Value;",
          "                        var label   = m.Groups[\"label\"].Value;",
          "                        var eol     = m.Groups[\"eol\"].Value;",
          "                        ",
          "                        if(apifun.Contains(label))",
          "                        {",
          "                            return def + label + eol;",
          "                        }",
          "",
          "                        if(variables.ContainsKey(label))",
          "                        {",
          "                            return def + variables[label] + eol;",
          "                        }",
          "",
          "                        if(uniqVars + 1 > vdict.Length)",
          "                        {",
          "                            throw new OverflowException(\"vdict does not contain data for new labels\");",
          "                        }",
          "                        variables[label] = vdict[uniqVars++];",
          "                        return def + variables[label] + eol;",
          "                    },",
          "                    RegexOptions.IgnoreCase | RegexOptions.Multiline",
          "                );",
          "",
          "",
          "                /* exit/B */",
          "",
          "                content = Regex.Replace(content, @\"exit\\s*(?:\\/B\\s*?(?'code'\\d+|(?:!|%)\" +VNAME+ @\"(?:!|%)?)|\\/B)\\s*?\", (m) =>",
          "                {",
          "                    string ret  = \"exit/B\";",
          "                    string code = m.Groups[\"code\"].Value;",
          "",
          "                    if(m.Groups[\"code\"].Success)",
          "                    {",
          "                        // 'exit /B 0' is not equal to 'exit /B' - it will pass the latest raised code i.e. without changing it.",
          "                        return ret + code;",
          "                    }",
          "                    return ret;",
          "                },",
          "                RegexOptions.IgnoreCase);",
          "",
          "",
          "                /* pseudo arguments from labels */",
          "",
          "                content = Regex.Replace(content, @\"^\\s*(?'label':\" + VNAME + @\").*?\\r\\n\", (m) =>",
          "                {",
          "                    return m.Groups[\"label\"].Value + \"\\r\\n\";",
          "                },",
          "                RegexOptions.IgnoreCase | RegexOptions.Multiline);",
          "",
          "",
          "                /* comments */",
          "",
          "                content = Regex.Replace(content, @\"(^\\s*?(?'l'::!|rem|::)\\s+)(?'d'.*?)\\r\\n\", (m) =>",
          "                {",
          "                    if(m.Groups[\"l\"].Value == \"::!\" || m.Groups[\"d\"].Value.StartsWith(\"Copyright \")) return m.Value;",
          "",
          "                    return string.Empty;",
          "                },",
          "                RegexOptions.IgnoreCase | RegexOptions.Multiline);",
          "",
          "",
          "                /* syntax */",
          "",
          "                content = Regex.Replace(content, @\"(\\r\\n)\\s*\", \"$1\");",
          "                content = Regex.Replace(content, @\"\\s+(\\r\\n)\", \"$1\");",
          "                content = content.Replace(\"\\r\\n)\", \")\");",
          "                content = content.Replace(\"(\\r\\n\", \"(\");",
          "",
          "                Func<string, string> InlineBlocksIf = null;",
          "                InlineBlocksIf = (input) =>",
          "                {",
          "                    if(input.IndexOfAny(new[] { '(', ')' }) == -1) return null;",
          "                    return Regex.Replace",
          "                    (",
          "                        input,",
          "                        @\"",
          "                        (?'lim'^|\\r\\n|[\\s)&])",
          "                        (?'cond'else\\s.*|if\\s.+?(?!\\(x86\\).+?))",
          "                        \\((?'body'",
          "                            (?>",
          "                                [^\\(\\)]",
          "                            |",
          "                                \\((?<R>)",
          "                            |",
          "                                \\)(?<-R>)",
          "                            )*",
          "                            (?(R)(?!))",
          "                        )\\)",
          "                        \",",
          "                        (_m) =>",
          "                        {",
          "                            string lim  = _m.Groups[\"lim\"].Value;",
          "                            string cond = _m.Groups[\"cond\"].Value;",
          "                            string body = _m.Groups[\"body\"].Value;",
          "",
          "                            string ret = InlineBlocksIf(_m.Groups[\"body\"].Value);",
          "                            if(ret == null) return lim + \"(\" + cond + \"(\" + body + \"))&\";",
          "",
          "                            return lim + \"(\" + cond + \"(\" + ret + \"))&\";",
          "                        },",
          "                        RegexOptions.IgnorePatternWhitespace",
          "                    );",
          "                };",
          "                content = InlineBlocksIf(content);",
          "                content = Regex.Replace(content, @\"\\)\\s*&\\s*\\(\\s*else\\s\", \"else \");",
          "                content = Regex.Replace(content, @\"\\)\\s*&\\s*\\)\", \"))\");",
          "                content = Regex.Replace(content, @\"\\)\\s*&\\s*\\r\\n\", \")\\r\\n\");",
          "",
          "                content = Regex.Replace",
          "                (",
          "                    content,",
          "                    @\"(^(?:setlocal|endlocal|rmdir|shift|call|exit|echo|del|goto|set)[:/\\w\\S ]*)\\r\\n(?![:<])\",",
          "                    (_m) =>",
          "                    {",
          "                        if(_m.Value.IndexOfAny(new[] { '&', '|' }) != -1) return _m.Value;",
          "                        return _m.Groups[1].Value + \"&\";",
          "                    },",
          "                    RegexOptions.Multiline | RegexOptions.IgnoreCase",
          "                );",
          "                // GetNuTool, Y-84",
          "                content = Regex.Replace(content, @\"(?<!\\*)&(setlocal\\s.+?DelayedExpansion)\", \"\\r\\n$1\", RegexOptions.IgnoreCase);",
          "",
          "                // hMSBuild, Y-50",
          "                content = Regex.Replace(content, @\"(setlocal\\s.+?DelayedExpansion)&@echo off\", \"$1\", RegexOptions.IgnoreCase);",
          "",
          "                content = Regex.Replace(content, @\"\\)\\s*\\r\\n\\s*\\(\", \")&(\");",
          "",
          "                content = Regex.Replace(content, @\"\\s+in\\s*\\(([0-9., ]*?)\\)\\s*do\\s*(\\()?\", (mfor) =>",
          "                {",
          "                    return string.Format(\" in ({0})do {1}\", mfor.Groups[1].Value.Replace(\" \", \"\"), mfor.Groups[2].Value);",
          "                },",
          "                RegexOptions.IgnoreCase);",
          "",
          "                content = Regex.Replace(content, @\"\\s*\\)\\s*(else\\s)\", \")$1\", RegexOptions.IgnoreCase);",
          "                content = Regex.Replace(content, @\"\\(\\s+(goto|set|call)\\s+\", \"($1 \", RegexOptions.IgnoreCase);",
          "",
          "                Func<string, string> InlineBlocksFor = null;",
          "                InlineBlocksFor = (input) =>",
          "                {",
          "                    return Regex.Replace",
          "                    (",
          "                        input,",
          "                        @\"",
          "                        (?'lim'^|\\r\\n|[\\s)&])",
          "                        (?'def'for\\s[^(]+?\\([^)]+?\\)\\s*do\\s*)",
          "                        \\((?'body'",
          "                            (?>",
          "                                [^\\(\\)]",
          "                            |",
          "                                \\((?<R>)",
          "                            |",
          "                                \\)(?<-R>)",
          "                            )*",
          "                            (?(R)(?!))",
          "                        )\\)",
          "                        \\s*&?",
          "                        \",",
          "                        (_m) =>",
          "                        {",
          "                            string lim  = _m.Groups[\"lim\"].Value;",
          "                            string def  = _m.Groups[\"def\"].Value;",
          "                            string body = _m.Groups[\"body\"].Value;",
          "",
          "                            return lim + \"(\" + def + \"(\" + body + \"))&\";",
          "                        },",
          "                        RegexOptions.IgnorePatternWhitespace",
          "                    );",
          "                };",
          "                content = InlineBlocksFor(content);",
          "                content = Regex.Replace(content, @\"\\)\\s*&\\s*:\", \")\\r\\n:\");",
          "",
          "",
          "                /* line packing */",
          "",
          "                Func<string, int, string, string> splitLongLines = (input, lim, wrd) =>",
          "                {",
          "                    var spl = new StringBuilder(content.Length + 100);",
          "                    for(int i = 0; i < content.Length;)",
          "                    {",
          "                        int start = i;",
          "                        int end = content.IndexOf(\"\\r\\n\", start + 1);",
          "                        if(end == -1)",
          "                        {",
          "                            spl.Append(content.Substring(start));",
          "                            break;",
          "                        }",
          "                        i = end;",
          "",
          "                        int len = end - start;",
          "                        if(len <= lim)",
          "                        {",
          "                            spl.Append(content.Substring(start, len));",
          "                            continue;",
          "                        }",
          "",
          "                        int pos = content.IndexOf(wrd, start + lim - wrd.Length);",
          "                        if(pos == -1)",
          "                        {",
          "                            spl.Append(content.Substring(start, end - start));",
          "                            continue;",
          "                        }",
          "",
          "                        string a = content.Substring(start, pos - start);",
          "                        spl.AppendLine(a);",
          "                        string b = content.Substring(++pos, end - pos);",
          "                        spl.Append(b);",
          "                    }",
          "                    return spl.ToString();",
          "                };",
          "                // max 2047 or 8191 (XP+) characters per line",
          "                content = splitLongLines(content, 1700, \"&echo\");",
          "",
          "                using(var writer = new StreamWriter(_OUTPUT, false, utf8noId))",
          "                writer.Write(review(content));",
          "",
          "                Console.WriteLine(\"{0} -> {1}\", _CORE, _OUTPUT);",
          "            }",
          "",
          "            File.WriteAllText(_CORE, review(File.ReadAllText(_CORE, Encoding.UTF8)), utf8noId);",
          "",
          "            /* map */",
          "",
          "            using(var wmap = new StreamWriter(_CORE + \".map\", false, utf8noId))",
          "            {",
          "                string map = string.Empty;",
          "                foreach(var v in variables) map += string.Format(\"{0}={1}{2}\", v.Value, v.Key, Environment.NewLine);",
          "                wmap.Write(map);",
          "            }",
          "",
          "            string mtpl =",
          "@\"<?xml version=\"\"1.0\"\" encoding=\"\"utf-8\"\"?>",
          "<Project ToolsVersion=\"\"4.0\"\" xmlns=\"\"http://schemas.microsoft.com/developer/msbuild/2003\"\">",
          "  <Target Name=\"\"vmap\"\">",
          "{0}",
          "  </Target>",
          "</Project>\";",
          "",
          "            using(var wmap = new StreamWriter(_CORE + \".map.targets\", false, utf8noId))",
          "            {",
          "                string map = string.Empty;",
          "                foreach(var v in variables)",
          "                {",
          "                    map += string.Format",
          "                    (",
          "                        \"<CreateProperty Value=\\\"{0}({1})\\\"><Output TaskParameter=\\\"Value\\\" PropertyName=\\\"{2}\\\"/></CreateProperty>{3}\",",
          "                        \"$\",",
          "                        v.Value,",
          "                        v.Key,",
          "                        Environment.NewLine",
          "                    );",
          "                }",
          "                wmap.Write(string.Format(mtpl, map));",
          "            }",
          "",
          "            return 0;",
          "        }",
          "    }",
          "}"
        ]
      }
    },
    {
      "Enabled": true,
      "Name": "MgrFinalize",
      "Caption": "Finalization of the manager ...",
      "IgnoreIfBuildFailed": true,
      "Process": {
        "$type": "net.r_eg.vsSBE.Events.EventProcess, vsSolutionBuildEvent",
        "Waiting": true,
        "Hidden": false,
        "TimeLimit": 400
      },
      "Mode": {
        "$type": "net.r_eg.vsSBE.Events.ModeScript, vsSolutionBuildEvent",
        "Type": "Script",
        "Command__": [
          "#[IO copy.file(\"$(dxpWZ).m.core.bat\", \"$(dxpWZ)\", true)]",
          "#[IO delete.files({\"$(dxpWZ).m.core.bat\"})]",
          "",
          "#[try",
          "{",
          "    #[IO writeLine(STDOUT):",
          "        #[IO cmd(\"copy /Y/B $(dxpWZ)+\\\"$(embdCore)\\\" $(dxpWZ)\")]",
          "     ]",
          "}",
          "catch(err, msg)",
          "{",
          "    #[IO write(STDOUT): Try `type` ... ]",
          "    ",
          "    #[IO cmd(\"type \\\"$(embdCore)\\\">>$(dxpWZ)\")]",
          "    #[IO writeLine(STDOUT): ok]",
          "",
          "}]",
          "",
          "~ embd core aliases",
          "#[var embdAliases = set _kH=%~n0 -hMSBuild]",
          "",
          "#[IO replace.Regex(\"$(dxpWZ)\", \"(setlocal\\s.+?DelayedExpansion)&@echo off\", \"$1&$(embdAliases)\")]",
          "",
          "##[IO replace.Regex(",
          "    \"$(dxpWZ)\", \"(?:(?:echo\\.&)?echo\\s+hMSBuild\\s+[\\s\\S]+%~n0.+?&goto\\s+)\", \"echo 0_0 off&goto \"",
          ")]",
          "",
          "#[IO replace.Regex(\"$(dxpWZ)\", \"(@echo off)\\s*&\\s*echo.*?exit\\s*/B\\s*\\d+\", \"$1\")]",
          "",
          "#[IO copy.file(\"$(dxpWZ)\", \"$(odir)/\", true)]",
          "",
          "",
          "#[$(mgrTests = \"$(odir)/tests/\")]",
          "",
          "#[IO copy.file({ \"$(dirsrc)hMSBuild/tests/*.bat\" }, \"$(mgrTests)\", true, { \"dbg*.bat\", \"a.bat\" })]",
          "#[IO copy.file({ \"$(dirsrc)hMSBuild/tests/a.bat\" }, \"$(mgrTests)hMSBuild/\", true)]",
          "#[IO copy.file({ \"$(dirsrc)hMSBuild/GetNuTool/tests/*.bat\" }, \"$(mgrTests)GetNuTool/\", true)]",
          "",
          "",
          "#[IO copy.file(",
          "{",
          "    \"$(dbin)*.map\",",
          "    \"$(dbin)*.targets\"",
          "}, ",
          "\"$(odir)/maps/\", true",
          ")]",
          "",
          "#[IO delete.files({ \"$(dbin)*.map*\" })]",
          "",
          "#[IO copy.file(",
          "{",
          "    \"$(mbatch)ManagerKeyTests.bat\",",
          "    \"$(mbatch)ManagerKeyTests.targets\",",
          "    \"$(mbatch)_run.bat\",",
          "    \"$(mbatch)a.bat\"",
          "}, ",
          "\"$(mgrTests)\", true",
          ")]",
          "",
          "#[IO copy.file(\"$(hCore)bat\", \"$(mgrTests)dbghcore.bat\", true)]",
          "#[IO copy.file(\"$(dxpWZ)\", \"$(mgrTests)dbgdcore.bat\", true)]",
          "",
          "#[File replace(\"$(mgrTests)ManagerKeyTests.bat\", \"$version$\", \"$(pVerRel)\")]"
        ]
      }
    },
    {
      "Enabled": true,
      "Name": "OfflineVersion",
      "Caption": "Preparing Offline version ...",
      "IgnoreIfBuildFailed": true,
      "ToConfiguration": [
        "PublicRelease|Any CPU",
        "Release|Any CPU"
      ],
      "Process": {
        "$type": "net.r_eg.vsSBE.Events.EventProcess, vsSolutionBuildEvent",
        "Waiting": true,
        "Hidden": false,
        "TimeLimit": 400
      },
      "Mode": {
        "$type": "net.r_eg.vsSBE.Events.ModeScript, vsSolutionBuildEvent",
        "Type": "Script",
        "Command__": [
          "#[$(mgrOffline = \"$(dirsrc)DllExport\\\\Manager\\\\batch\\\\Manager.offline\")]",
          "",
          "#[IO copy.directory(\"$(odir)\", \"$(dbin)/raw.offline/packages/DllExport\", true, true)]",
          "#[IO copy.file(\"$(mgrOffline).bat\", \"$(dbin)/raw.offline/DllExport.bat\", true)]",
          "#[IO copy.file(\"$(mgrOffline).txt\", \"$(dbin)/raw.offline/Readme.txt\", true)]",
          "#[IO copy.file({ \".gitattributes\" }, \"$(dbin)/raw.offline/\", true)]",
          "##[IO write(\"$(dbin)/raw.offline/DllExport_Configure.bat\"): DllExport -action Configure %*]",
          "",
          ""
        ]
      }
    },
    {
      "Enabled": true,
      "Name": "ActPack",
      "Caption": "Packing with GetNuTool ...",
      "IgnoreIfBuildFailed": true,
      "Mode": {
        "$type": "net.r_eg.vsSBE.Events.ModeScript, vsSolutionBuildEvent",
        "Type": "Script",
        "Command__": [
          "#[( $(isPubRel) )",
          "{",
          "    #[IO delete.files({ \"$(odir)tools\\*.pdb\" })]",
          "}]",
          "",
          "#[$(shaListDir = $(odir))] #[$(searchSubDirs = '1')]",
          "#[Core events.Post.item(\"ShaList\").run()]",
          "",
          "Note: 1.5 and 1.6 contains bug if used 1.2.3-alpha, 1.2.3-beta-2, 1.2.3-rc ...",
          "##[NuGet gnt.raw(\"/t:pack /p:ngin=\\\"$(odir)\\\" /p:ngout=\\\"$(dbin)\\\"\")] ",
          "#[IO cmd(\".tools\\gnt.bat /t:pack /p:ngin=\\\"$(SolutionDir)$(odir)\\\" /p:ngout=\\\"$(SolutionDir)$(dbin)\\\"\", 400)]",
          "",
          "#[( $(cfgname) != \"Debug\" )",
          "{",
          "    #[($(revBuild) == \"\" || $(revBuild) ~= \"*\") {",
          "        #[$(zipname = \"DllExport.$(pVerRel).zip\")]",
          "    }",
          "    else {",
          "        #[$(zipname = \"DllExport.$(pVer).$(revBuild)$(partRelV)+$(bSha1).zip\")]",
          "    }]",
          "",
          "    ~ Offline version",
          "    ",
          "    #[$(shaListDir = \"$(dbin)raw.offline\\\\\")]",
          "    #[$(searchSubDirs = '1')]",
          "    #[Core events.Post.item(\"ShaList\").run()]",
          "    ",
          "    #[7z pack.directory(",
          "        \"$(dbin)raw.offline\", ",
          "        \"$(dbin)offline.$(zipname)\",",
          "        Zip,",
          "        Deflate,",
          "        1",
          "    )]",
          "    ",
          "}]",
          "",
          "#[$(shaListDir = $(dbin))] #[$(searchSubDirs = '0')]",
          "#[Core events.Post.item(\"ShaList\").run()]"
        ]
      }
    },
    {
      "Enabled": true,
      "Name": "PkgLink",
      "Caption": "Link package and manager",
      "IgnoreIfBuildFailed": true,
      "Mode": {
        "$type": "net.r_eg.vsSBE.Events.ModeScript, vsSolutionBuildEvent",
        "Type": "Script",
        "Command__": [
          "#[$(dbgPkgDir = \"$(dbin.Replace('/', '\\'))packages\\\\\")]",
          "",
          "#[IO copy.directory(\"\", \"$(dbgPkgDir)\", true)]",
          "#[IO scall(\"cmd\", \"/C mklink /J $(dbgPkgDir)DllExport.$(pVerRel) $(odir.Replace('/', '\\'))\")]"
        ]
      }
    },
    {
      "Enabled": true,
      "Name": "Assets",
      "IgnoreIfBuildFailed": true,
      "Mode": {
        "$type": "net.r_eg.vsSBE.Events.ModeScript, vsSolutionBuildEvent",
        "Type": "Script",
        "Command__": [
          "#[try",
          "{",
          "    #[IO delete.directory(\"$(RootAssetsDir)\", true)]",
          "} catch{ F-53, SobaScript }]",
          "",
          "#[IO copy.directory(\"\", \"$(RootAssetsDir)\", true)]",
          "#[IO scall(\"cmd\", \"/C mklink /J $(RootAssetsDir)\\DllExport $(odir.Replace('/', '\\'))\")]",
          "",
          "",
          "#[File scall(\"DllExport.bat\", \"-packages $(RootAssetsDir) -dxp-version actual -action Restore >nul\", 60)]",
          "#[File scall(\".tools\\hMSBuild.bat\", \"~x ~c $(cfgname) ~p \\\"$(Platform)\\\" assets.sln -t:restore -t:build /p:RootAssetsDir=$(RootAssetsDir) >nul\", 200)]"
        ]
      }
    }
  ],
  "SlnOpened": [
    {
      "Enabled": true,
      "Name": "ActDefConst",
      "Caption": "define dynamic constants",
      "BuildType": "BeforeAndAfter",
      "Mode": {
        "$type": "net.r_eg.vsSBE.Events.ModeScript, vsSolutionBuildEvent",
        "Type": "Script",
        "Command__": [
          "$(defConstList = \"CONFVER_EXISTS\")",
          "$(+DefConstDynamic = $(defConstList):Configurator)"
        ]
      }
    }
  ]
}